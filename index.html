<!DOCTYPE html>
<html>
    <head>
        <title>Bouncing Ball</title>
        <meta charset="UTF-8">
    </head>

    <body>
        <center><canvas id="canvas"></canvas></center>
        <blockquote>If any one were to ask me what in my opinion was the dullest and most stupid spot on the face of the Earth, I should decidedly say Chelmsford.</blockquote>
    </body>

    <script>

const canvas    = document.getElementById("canvas");
const ctx       = canvas.getContext("2d");
const width     = screen.availWidth - 50;
const height    = screen.availHeight - 250;

canvas.width    = width;
canvas.height   = height;

const distance = p1 => p2 => Math.hypot(p2.x-p1.x, p2.y-p1.y);
const between = x => a => b => x >= a && x <= b;
const setWithin = x => a => b => Math.max(Math.min(x, b), a);

const gravity = 0;
const frictionCoefficient = 0.8;
const elasticity = 0.5;
const radius = 20;

const Ball = function (x, y, color) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.xv = 0;
    this.yv = 0;
    this.dragged = false;
    balls.push(this);
};
Ball.physics = function (ball) {
    ball.yv += gravity/10;
    ball.x += ball.xv;
    ball.y += ball.yv;
    balls.forEach(ballB => {
        if (distance(ball)(ballB) <= 2*radius && distance(ball)(ballB) > 0) {
            let direction = Math.atan2(ballB.x-ball.x, ballB.y-ball.y);
            while (distance(ball)(ballB) <= 2*radius) {
                ball.x -= Math.sin(direction);
                ball.y -= Math.cos(direction);
            };
            let midpoint = {x: (ball.x + ballB.x)/2, y: (ball.y + ballB.y)/2};
            let v = Math.hypot(ball.xv, ball.yv);
            let vb = Math.hypot(ballB.xv, ballB.yv);
            let velocity = (v + vb) * elasticity / 2;
            let deflect = ball => {
                let direction = Math.atan2(ball.x-midpoint.x, ball.y-midpoint.y);
                ball.xv = Math.cos(direction)*velocity/2;
                ball.yv = Math.sin(direction)*velocity/2;
                ball.x += ball.xv;
                ball.y += ball.yv;
            };
            deflect(ball);
            deflect(ballB);
            console.log(v, vb, velocity);
        };
    });
    if (!between(ball.x)(radius)(width-radius)) {
        ball.x = setWithin(ball.x)(radius)(width-radius);
        ball.xv = -ball.xv*elasticity;
    };
    if (ball.y >= height - radius) {
        ball.xv -= Math.sign(ball.xv)*(1-frictionCoefficient);
    };
    if (!between(ball.y)(radius)(height-radius)) {
        ball.y = setWithin(ball.y)(radius)(height-radius);
        ball.yv = -ball.yv*elasticity;
    };
};
Ball.update = function (ball) {
    if (!ball.dragged) Ball.physics(ball);
    let {x, y, color} = ball;
    ctx.fillStyle = color;
    ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2*Math.PI);
    ctx.fill();
};

const balls = [];
var selectedBall = null;

new Ball(100, 100, "red");
new Ball(200, 100, "blue");
new Ball(300, 100, "green");
new Ball(400, 100, "yellow");

let mouse = {x: 0, y: 0, xv: 0, yv: 0};
const mouseUpdate = e => {
    mouse.xv = e.clientX - mouse.x;
    mouse.yv = e.clientY - mouse.y;
    mouse.x = e.clientX;
    mouse.y = e.clientY;
};
canvas.addEventListener("mousemove", mouseUpdate);

const selectBall = e => {
    balls.forEach(ball => {
        if (distance(ball)(mouse) <= 2*radius + 10) selectedBall = ball;
    });
    if (selectedBall) selectedBall.dragged = true;
};
const deselectBall = e => {
    if (!selectedBall) return;
    selectedBall.dragged = false;
    selectedBall.xv = mouse.xv;
    selectedBall.yv = mouse.yv;
    selectedBall = null;
};
canvas.addEventListener("mousedown", selectBall);
canvas.addEventListener("mouseup", deselectBall);

const mainloop  = () => {
    ctx.clearRect(0, 0, width, height);
    ctx.strokeRect(0, 0, width, height);
    balls.forEach(Ball.update);
    if (selectedBall) {
        selectedBall.x = mouse.x - radius;
        selectedBall.y = mouse.y - radius/2;
    };
    requestAnimationFrame(mainloop);
};

requestAnimationFrame(mainloop);

    </script>
</html>